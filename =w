use chrono::Utc;
use std::collections::LinkedList;

use crate::{
    types::block::{Block, Transaction},
    utils::hasher::{block_hasher, transactions_hasher},
};

use super::miner::mine_blocks;

pub struct Blockchain {
    // List of peers/blocks in the chain
    pub blocks: LinkedList<Block>,

    // The list of transactions which are to be added in the next block to be mined
    // It's a mempool of transactions
    pub current_transactions: Vec<Transaction>,

    // Archived transactions, similar to a log/ledger for transactions
    pub archived_transactions: Vec<Transaction>,

    // reference for the last block which was added to the chain
    pub(crate) last_block: Option<Block>,

    // Difficulty level for mining the block
    pub(crate) difficulty: usize,
}

impl Blockchain {
    // Genesis Block: First Block of the Chain
    pub fn new(&mut self) -> Blockchain {
        let genesis_block = Block {
            index: 0,
            prev_hash: "0".to_string(),
            nonce: 0,
            timestamp: Utc::now(),
            transactions: Vec::new(),
            merkle_root: String::new(),
        };

        self.blocks.push_back(genesis_block);

        Blockchain {
            blocks: self.blocks.clone(),
            current_transactions: Vec::new(),
            archived_transactions: Vec::new(),
            last_block: None,
            // Default difficulty is set to 3
            difficulty: 3,
        }
    }

    pub fn add_new_block(self) {
        let block = Block {
            index: self.last_block.index + 1,
            prev_hash: block_hasher(self.last_block.clone()),
            nonce: 0,
            timestamp: Utc::now(),
            transactions: self.current_transactions.clone(),
            merkle_root: transactions_hasher(self.current_transactions),
        };

        mine_blocks(&mut block, self.difficulty)
    }

    pub fn set_new_transaction(
        &mut self,
        sender: String,
        receiver: String,
        amount: u32,
        transaction_fee: u32,
    ) -> Transaction {
        let transaction = Transaction {
            sender,
            receiver,
            amount,
            transaction_fee,
            timestamp: Utc::now(),
        };

        self.current_transactions.push(transaction.clone());
        transaction
    }

    pub fn get_mempool(self) -> Vec<Transaction> {
        self.current_transactions
    }

    pub fn get_last_block(self) -> Option<Block> {
        if self.last_block.is_some() {
            self.last_block
        } else {
            log::error!("Genesis block doesn't have a previous block!");
            None
        }
    }
}
